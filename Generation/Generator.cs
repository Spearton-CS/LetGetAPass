using LetGetAPass.Structures;

namespace LetGetAPass.Generation
{
    /// <summary>Provides methods for password generation. Supports crypto-random and pseudo-random functions</summary>
    public static class Generator
    {
        /// <summary>Generates password with length <paramref name="len"/> filled from <paramref name="bounds"/> checking <paramref name="reqs"/> and depending on <paramref name="rnd"/></summary>
        /// <param name="rnd">Your logic for random number generation</param>
        /// <param name="len">Length of password. Defaults used when it less or equal to 0</param>
        /// <param name="bounds">List of chars to generate password</param>
        /// <param name="reqs">Requirements, which must be applied to end password</param>
        /// <returns>String, representing password generated by function</returns>
        /// <exception cref="InvalidDataException">Bounds invalid for <paramref name="reqs"/></exception>
        public static string Generate(Func<int, int, int> rnd, int len = -1, IReadOnlyList<char>? bounds = null, PasswordRequirements reqs = PasswordRequirements.None)
        {
            if (bounds is null)
            {
                bounds = new ReadOnlyListsCollection<char>(KnownPassBounds.DefaultCharBounds, KnownPassBounds.DefaultSpecialsBounds);
            }
            else
            {
                bool upper = false, lower = false, digit = false, letter = false;

                foreach (char c in bounds)
                {
                    if (char.IsUpper(c))
                        upper = true;
                    else if (char.IsLower(c))
                        lower = true;
                    else if (char.IsDigit(c))
                        digit = true;
                    else if (char.IsLetter(c))
                        letter = true;
                }

                if (!upper && reqs.HasFlag(PasswordRequirements.HaveUppercase))
                    throw new InvalidDataException("Bounds must have Uppercase char(s). User requirements");
                else if (!lower && reqs.HasFlag(PasswordRequirements.HaveLowercase))
                    throw new InvalidDataException("Bounds must have Lowercase char(s). User requirements");
                else if (!digit && reqs.HasFlag(PasswordRequirements.HaveDigit))
                    throw new InvalidDataException("Bounds must have Digit char(s). User requirements");
                else if (!letter && reqs.HasFlag(PasswordRequirements.HaveLetter))
                    throw new InvalidDataException("Bounds must have Letter char(s). User requirements");
            }

            if (len <= 0)
                len = rnd(KnownPassBounds.DefaultMinLen, KnownPassBounds.DefaultMaxLen);

            char[] gen = new char[len];



            return new string(gen);

        }

        /// <summary>Using <see cref="Random.Shared"/> with <see cref="Generate(Func{int, int, int}, int, IReadOnlyList{char}?, PasswordRequirements)"/></summary>
        /// <param name="len"></param>
        /// <param name="bounds"></param>
        /// <param name="reqs"></param>
        /// <returns></returns>
        public static string GenPseudoRnd(int len = -1, IReadOnlyList<char>? bounds = null, PasswordRequirements reqs = PasswordRequirements.None)
            => Generate(Random.Shared.Next, len, bounds, reqs);
        /// <summary>Using <see cref="Random"/> with <paramref name="seed"/> with <see cref="Generate(Func{int, int, int}, int, IReadOnlyList{char}?, PasswordRequirements)"/></summary>
        /// <param name="seed"></param>
        /// <param name="len"></param>
        /// <param name="bounds"></param>
        /// <param name="reqs"></param>
        /// <returns></returns>
        public static string GenPseudoRnd(int seed, int len = -1, IReadOnlyList<char>? bounds = null, PasswordRequirements reqs = PasswordRequirements.None)
        {
            Random rnd = new(seed);
            return Generate(rnd.Next, len, bounds, reqs);
        }
        
        //OWN PSEUDO-RANDOM

        //CRYPTO-RANDOM
    }
}